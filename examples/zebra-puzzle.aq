#!/usr/local/bin/aq

# src: https://en.wikipedia.org/wiki/Zebra_Puzzle

# FIXME move to prelude/ArrayFunctions.aq
pop := \m -> {Remove m[size(m) - 1];};
push := \m, v -> {m[size(m)] := v;};

constraints := {};

# There are five houses.
houses := { {}, {}, {}, {}, {} };

# The Englishman lives in the red house.
Call push(constraints, {
    relation : 'self',
    a : { nationality : 'Englishman' },
    b : { color : 'red' },
});

# The Spaniard owns the dog.
Call push(constraints, {
    relation : 'self',
    a : { nationality : 'Spaniard' },
    b : { pet : 'dog' },
});

# Coffee is drunk in the green house.
Call push(constraints, {
    relation : 'self',
    a : { beverage : 'coffee' },
    b : { color : 'green' },
});

# The Ukrainian drinks tea.
Call push(constraints, {
    relation : 'self',
    a : { nationality : 'Ukrainian' },
    b : { beverage : 'tea' },
});

# The green house is immediately to the right of the ivory house.
Call push(constraints, {
    relation : 'right to',
    a : { color : 'ivory' },
    b : { color : 'green' },
});

# The Old Gold smoker owns snails.
Call push(constraints, {
    relation : 'self',
    a : { smoke : 'Old Gold' },
    b : { pet : 'snail' },
});

# Kools are smoked in the yellow house.
Call push(constraints, {
    relation : 'self',
    a : { smoke : 'Kools' },
    b : { color : 'yellow' },
});

# Milk is drunk in the middle house.
houses[2].beverage := 'milk';

# The Norwegian lives in the first house.
houses[0].nationality := 'Norwegian';

# The man who smokes Chesterfields lives in the house next to the man with the fox.
Call push(constraints, {
    relation : 'next to',
    a : { pet : 'fox' },
    b : { smoke : 'Chesterfields' },
});

# Kools are smoked in the house next to the house where the horse is kept.
Call push(constraints, {
    relation : 'next to',
    a : { pet : 'horse' },
    b : { smoke : 'Kools' },
});

# The Lucky Strike smoker drinks orange juice.
Call push(constraints, {
    relation : 'self',
    a : { smoke : 'Lucky Strike' },
    b : { beverage : 'orange juice' },
});

# The Japanese smokes Parliaments.
Call push(constraints, {
    relation : 'self',
    a : { nationality : 'Japanese' },
    b : { smoke : 'Parliaments' },
});

# The Norwegian lives next to the blue house.
Call push(constraints, {
    relation : 'next to',
    a : { color : 'blue' },
    b : { nationality : 'Norwegian' },
});

# Solve!
# TODO this algorithm doesn't work yet
constraintself := \k, v, constraint, a, b -> {
    If not constraint.used and v : a:
        Call foreach(b, \k2, v2 -> {houses[j][k2] := v2;});
        Write 'used constraint: ' & DictToStr(constraint);
        constraint.used := true;
    EndIf
};
constraintrightto := \k, v, constraint, a, b -> {
    If not constraint.used and v : a:
        Call foreach(b, \k2, v2 -> {houses[j + 1][k2] := v2;});
        Write 'used constraint: ' & DictToStr(constraint);
        constraint.used := true;
    EndIf
};
constraintnextto := \k, v, constraint, a, b -> {
    If not constraint.used and v : a:
        l := -1;
        If j = 0: l := j + 1;
        ElseIf j = 4: l := j - 1;
        ElseIf forall(b, \k2, v2 -> v2 : houses[j - 1] and not v2 : houses[j + 1]): l := j + 1;
        ElseIf forall(b, \k2, v2 -> not v2 : houses[j - 1] and v2 : houses[j + 1]): l := j - 1;
        EndIf
        If l <> -1:
            Call foreach(b, \k2, v2 -> {houses[l][k2] := v2;});
            Write 'used constraint: ' & DictToStr(constraint);
            constraint.used := true;
        EndIf
    EndIf
};
Call foreach(constraints, \i, constraint -> {constraint.used := false;});
unusedconstraints := size(constraints);
Loop:
    Write 'unused constraints: ' & IntToStr(unusedconstraints);
    Call foreach(constraints, \i, constraint -> {
        If not constraint.used:
            Write 'testing constraint with relation ' & constraint.relation;
            Switch constraint.relation:
            Case 'self':
                For j From 0 To 4:
                    Call foreach(houses[j], \k, v -> {
                        Call constraintself(k, v, constraint, constraint.a, constraint.b);
                        Call constraintself(k, v, constraint, constraint.b, constraint.a);
                    });
                EndFor
            Case 'right to':
                For j From 0 To 4:
                    Call foreach(houses[j], \k, v -> {
                        Call constraintrightto(k, v, constraint, constraint.a, constraint.b);
                        Call constraintrightto(k, v, constraint, constraint.b, constraint.a);
                    });
                EndFor
            Case 'next to':
                For j From 0 To 4:
                    Call foreach(houses[j], \k, v -> {
                        Call constraintnextto(k, v, constraint, constraint.a, constraint.b);
                        Call constraintnextto(k, v, constraint, constraint.b, constraint.a);
                    });
                EndFor
            Default:
                Call error('Illegal relation ' & constraint.relation);
            EndSwitch
        EndIf
    });
    newunusedconstraints := size(filter(constraints, \i, constraint -> not constraint.used));
While newunusedconstraints < unusedconstraints:
    unusedconstraints := newunusedconstraints;
EndLoop

# Now, who drinks water?
r := filter(houses, \i, house -> exists(house, \k, v -> k eq 'beverage' and v eq 'water'));
Write 'The ' & r[0].nationality & ' drinks water.';

# Who owns the zebra?
r := filter(houses, \i, house -> exists(house, \k, v -> k eq 'pet' and v eq 'zebra'));
Write 'The ' & r[0].nationality & ' owns the zebra.';

#!/usr/local/bin/aq

# src: https://en.wikipedia.org/wiki/Zebra_Puzzle

# FIXME move to prelude/arrayfunctions.aq
pop := \m -> (remove m[size(m) - 1];);
push := \m, v -> (m[size(m)] := v;);

constraints := {};

# There are five houses.
houses := { {}, {}, {}, {}, {} };

# The Englishman lives in the red house.
call push(constraints, {
    relation : 'self',
    a : { nationality : 'Englishman' },
    b : { color : 'red' },
});

# The Spaniard owns the dog.
call push(constraints, {
    relation : 'self',
    a : { nationality : 'Spaniard' },
    b : { pet : 'dog' },
});

# Coffee is drunk in the green house.
call push(constraints, {
    relation : 'self',
    a : { beverage : 'coffee' },
    b : { color : 'green' },
});

# The Ukrainian drinks tea.
call push(constraints, {
    relation : 'self',
    a : { nationality : 'Ukrainian' },
    b : { beverage : 'tea' },
});

# The green house is immediately to the right of the ivory house.
call push(constraints, {
    relation : 'right to',
    a : { color : 'ivory' },
    b : { color : 'green' },
});

# The Old Gold smoker owns snails.
call push(constraints, {
    relation : 'self',
    a : { smoke : 'Old Gold' },
    b : { pet : 'snail' },
});

# Kools are smoked in the yellow house.
call push(constraints, {
    relation : 'self',
    a : { smoke : 'Kools' },
    b : { color : 'yellow' },
});

# Milk is drunk in the middle house.
houses[2].beverage := 'milk';

# The Norwegian lives in the first house.
houses[0].nationality := 'Norwegian';

# The man who smokes Chesterfields lives in the house next to the man with the fox.
call push(constraints, {
    relation : 'next to',
    a : { pet : 'fox' },
    b : { smoke : 'Chesterfields' },
});

# Kools are smoked in the house next to the house where the horse is kept.
call push(constraints, {
    relation : 'next to',
    a : { pet : 'horse' },
    b : { smoke : 'Kools' },
});

# The Lucky Strike smoker drinks orange juice.
call push(constraints, {
    relation : 'self',
    a : { smoke : 'Lucky Strike' },
    b : { beverage : 'orange juice' },
});

# The Japanese smokes Parliaments.
call push(constraints, {
    relation : 'self',
    a : { nationality : 'Japanese' },
    b : { smoke : 'Parliaments' },
});

# The Norwegian lives next to the blue house.
call push(constraints, {
    relation : 'next to',
    a : { color : 'blue' },
    b : { nationality : 'Norwegian' },
});

# Solve!
# TODO this algorithm doesn't work yet
constraintself := \k, v, constraint, a, b -> (
    if not constraint.used and v : a (
        call foreach(b, \k2, v2 -> (houses[j][k2] := v2;));
        write 'used constraint: ' & dict2str(constraint);
        constraint.used := true;
    )
);
constraintrightto := \k, v, constraint, a, b -> (
    if not constraint.used and v : a (
        call foreach(b, \k2, v2 -> (houses[j + 1][k2] := v2;));
        write 'used constraint: ' & dict2str(constraint);
        constraint.used := true;
    )
);
constraintnextto := \k, v, constraint, a, b -> (
    if not constraint.used and v : a (
        l := -1;
        if j = 0 (l := j + 1;)
        elif j = 4 (l := j - 1;)
        elif forall(b, \k2, v2 -> v2 : houses[j - 1] and not v2 : houses[j + 1]) (l := j + 1;)
        elif forall(b, \k2, v2 -> not v2 : houses[j - 1] and v2 : houses[j + 1]) (l := j - 1;)
        if l <> -1 (
            call foreach(b, \k2, v2 -> (houses[l][k2] := v2;));
            write 'used constraint: ' & dict2str(constraint);
            constraint.used := true;
        )
    )
);
call foreach(constraints, \i, constraint -> (constraint.used := false;));
unusedconstraints := size(constraints);
loop (
    write 'unused constraints: ' & int2str(unusedconstraints);
    call foreach(constraints, \i, constraint -> (
        if not constraint.used (
            write 'testing constraint with relation ' & constraint.relation;
            switch constraint.relation:
            case 'self' (
                for j from 0 to 4 (
                    call foreach(houses[j], \k, v -> (
                        call constraintself(k, v, constraint, constraint.a, constraint.b);
                        call constraintself(k, v, constraint, constraint.b, constraint.a);
                    ));
                )
            )
            case 'right to' (
                for j from 0 to 4 (
                    call foreach(houses[j], \k, v -> (
                        call constraintrightto(k, v, constraint, constraint.a, constraint.b);
                        call constraintrightto(k, v, constraint, constraint.b, constraint.a);
                    ));
                )
            )
            case 'next to' (
                for j from 0 to 4 (
                    call foreach(houses[j], \k, v -> (
                        call constraintnextto(k, v, constraint, constraint.a, constraint.b);
                        call constraintnextto(k, v, constraint, constraint.b, constraint.a);
                    ));
                )
            )
            default (call error('Illegal relation ' & constraint.relation);)
        )
    ));
    newunusedconstraints := size(filter(constraints, \i, constraint -> not constraint.used));
) while newunusedconstraints < unusedconstraints (
    unusedconstraints := newunusedconstraints;
)

# Now, who drinks water?
r := filter(houses, \i, house -> exists(house, \k, v -> k eq 'beverage' and v eq 'water'));
write 'The ' & r[0].nationality & ' drinks water.';

# Who owns the zebra?
r := filter(houses, \i, house -> exists(house, \k, v -> k eq 'pet' and v eq 'zebra'));
write 'The ' & r[0].nationality & ' owns the zebra.';

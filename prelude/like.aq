#!/usr/local/bin/aq

run 'stringfunctions.aq';

# TODO make this function local to like()
likeh := \t : String, q : String ->
    # TODO can't use `and` here because it does not short circuit (yet?)
    #t ne '' and (like(t, q) or likeh(tail(t), q));
    if t ne '' (like(t, q) or likeh(tail(t), q)) else (false);

# a very simplistic implementation of like()
# handles ?, * and #
like := \s : String, p : String ->
    if s eq '' (
        containsonly(p, '*')
    ) elif p eq '' (
        false
    ) elif containsonly(p, '*') (
        true
    ) else (
        let hs = head(s), ts = tail(s),
            hp = head(p), tp = tail(p) (
            switch hp:
            case '?' (
                like(ts, tp)
            )
            case '*' (
                likeh(s, tp)
            )
            case '#' (
                isdigit(hs) and like(ts, tp)
            )
            default (
                hp eq hs and like(ts, tp)
            )
        )
    );

write 'true:  ' & bool2str(like('abc', '*'));
write 'true:  ' & bool2str(like('abc', '**'));
write 'false: ' & bool2str(like('abc', '??'));
write 'true:  ' & bool2str(like('abc', '???'));
write 'true:  ' & bool2str(like('abc', 'a*'));
write 'true:  ' & bool2str(like('abc', 'a*c'));
write 'true:  ' & bool2str(like('abc', 'a??'));
write 'true:  ' & bool2str(like('abc', 'a?c'));
write 'false: ' & bool2str(like('abc', 'abx'));
write 'false: ' & bool2str(like('abc', 'x*'));
write 'false: ' & bool2str(like('abc', 'x??'));
write 'false: ' & bool2str(like('abc', 'xyz'));
write 'false: ' & bool2str(like('abc', '###'));
write 'false: ' & bool2str(like('123', '##'));
write 'true:  ' & bool2str(like('123', '###'));
# TODO add more test cases
